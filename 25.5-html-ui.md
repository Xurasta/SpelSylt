# Branch 25.5: HTML/CSS UI Refactor

## Ã–versikt

I detta steg refaktorerar vi quiz-systemet frÃ¥n **canvas rendering** till **HTML + CSS**. Detta visar varfÃ¶r man ska vÃ¤lja rÃ¤tt verktyg fÃ¶r rÃ¤tt uppgift - canvas Ã¤r bra fÃ¶r spelet, men HTML/CSS Ã¤r bÃ¤ttre fÃ¶r UI.

### VarfÃ¶r Refaktorera?

**Problemet med Canvas UI:**
- **Manuell text wrapping** - MÃ¥ste rÃ¤kna pixlar och dela upp ord sjÃ¤lv (40+ rader kod)
- **HÃ¥rdkodade fÃ¤rger i JS** - `this.correctColor = '#4CAF50'` - svÃ¥rt att Ã¤ndra design
- **Ingen native hover** - MÃ¥ste tracka muspositionen och rita om allt
- **DÃ¥lig accessibility** - Screen readers kan inte lÃ¤sa canvas
- **Mycket kod** - 260+ rader fÃ¶r en enkel dialog

**FÃ¶rdelarna med HTML/CSS:**
- **Native text wrapping** - Browsers gÃ¶r det automatiskt
- **CSS fÃ¶r styling** - Separera utseende frÃ¥n logik
- **Native hover effects** - `:hover` i CSS, inga custom event handlers
- **Accessibility** - DOM element kan lÃ¤sas av screen readers
- **Mindre kod** - ~60 rader fÃ¶r samma funktionalitet

## Canvas vs HTML/CSS

### NÃ¤r ska man anvÃ¤nda Canvas?

**AnvÃ¤nd Canvas fÃ¶r:**
- Game rendering (enemies, towers, projectiles)
- MÃ¥nga objekt som rÃ¶r sig (100+ samtidigt)
- Pixelperfekt kontroll Ã¶ver rendering
- Custom draw operations (partiklar, trails, effekter)

**Exempel i vÃ¥r kod:**
```javascript
// Canvas Ã¤r perfekt fÃ¶r att rita mÃ¥nga enemies
enemies.forEach(enemy => {
    enemy.draw(ctx)  // Ritars varje frame
})
```

### NÃ¤r ska man anvÃ¤nda HTML/CSS?

**AnvÃ¤nd HTML/CSS fÃ¶r:**
- UI elements (buttons, dialogs, menus)
- Text som ska vara lÃ¤sbar och selectable
- Forms och input
- Saker som inte Ã¤ndras varje frame

**Exempel:**
```javascript
// HTML Ã¤r bÃ¤ttre fÃ¶r dialogs
<div id="quiz-dialog">
    <h2>Question 1/3</h2>
    <button>Option A</button>
</div>
```

### Hybrid Approach (VÃ¥rt val)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   HTML Body             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Canvas (z:1)     â”‚   â”‚  â† Game rendering
â”‚  â”‚ [Game graphics]  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ HTML (z:1000)    â”‚   â”‚  â† UI overlay
â”‚  â”‚ [Quiz Dialog]    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Canvas och HTML existerar samtidigt med **z-index layering**. Canvas fÃ¶r spelet, HTML fÃ¶r UI.

## HTML Templates

### VarfÃ¶r `<template>` Element?

IstÃ¤llet fÃ¶r att skapa alla element med JavaScript:
```javascript
// ğŸ˜© 60+ rader kod
const div = document.createElement('div')
const title = document.createElement('h2')
title.textContent = 'Quiz Time!'
div.appendChild(title)
// ... 50+ rader till
```

AnvÃ¤nder vi HTML `<template>`:
```html
<!-- âœ¨ Deklarativ och tydlig struktur -->
<template id="quiz-dialog-template">
  <div id="quiz-dialog-overlay">
    <div id="quiz-dialog">
      <h2 id="quiz-title">Quiz Time!</h2>
      <p id="quiz-question"></p>
      <div id="quiz-options"></div>
      <div id="quiz-result" class="hidden">
        <p id="result-text"></p>
        <p id="result-explanation"></p>
        <p id="result-reward"></p>
        <button class="continue-button">Continue</button>
      </div>
    </div>
  </div>
</template>
```

### Hur `<template>` Fungerar

**`<template>` Ã¤r speciell:**
1. **Renderas inte** - InnehÃ¥llet Ã¤r dolt tills du klonars det
2. **Inert** - Scripts kÃ¶rs inte, images laddas inte
3. **Kan klonas** - `.cloneNode(true)` fÃ¶r att skapa kopior
4. **Standard HTML5** - Fungerar i alla moderna browsers

**I koden:**
```javascript
createDialogElements() {
    // HÃ¤mta template frÃ¥n DOM
    const template = document.getElementById('quiz-dialog-template')
    
    // Klona innehÃ¥llet
    const clone = template.content.cloneNode(true)
    
    // HÃ¤mta element-referenser
    this.overlayEl = clone.querySelector('#quiz-dialog-overlay')
    this.titleEl = clone.querySelector('#quiz-title')
    // ... resten
    
    // LÃ¤gg till i body
    document.body.appendChild(this.overlayEl)
}
```

**FÃ¶rdelar:**
- **Separation of Concerns** - HTML i HTML-fil, inte i JS
- **Reusable** - Kan klona flera gÃ¥nger om behÃ¶vs
- **Web Components** - Samma pattern som anvÃ¤nds i moderna komponenter
- **LÃ¤sbart** - Ser strukturen direkt

## CSS Styling

### Overlay Pattern

```css
#quiz-dialog-overlay {
  position: fixed;      /* Ã–ver hela viewport */
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.8);  /* Semi-transparent backdrop */
  z-index: 1000;       /* Ã–ver canvas */
  display: flex;       /* Centrera dialog */
  align-items: center;
  justify-content: center;
}
```

**`position: fixed`** Ã¤r nyckeln - den ligger Ã¶ver canvas utan att pÃ¥verka spelets layout.

### Button States

```css
.quiz-option {
  background: rgba(60, 60, 80, 0.8);
  transition: all 0.2s ease;  /* Smooth animations */
}

.quiz-option:hover {
  background: rgba(80, 80, 100, 0.9);
  border-color: #4a9eff;
  transform: translateX(4px);  /* Slide effect */
}

.quiz-option.correct {
  background: rgba(46, 204, 113, 0.3);  /* Green */
  border-color: #2ecc71;
}
```

**CSS Classes** fÃ¶r olika states - mycket enklare Ã¤n att rita om allt i canvas.

## DOM Manipulation

### Dynamisk Content

**Rendera frÃ¥ga:**
```javascript
renderQuestion() {
    const question = this.currentQuestion
    
    // Uppdatera text (browser hanterar wrapping)
    this.titleEl.textContent = `Question ${this.currentQuestionIndex + 1}/${this.questions.length}`
    this.questionEl.textContent = question.question
    
    // Rensa tidigare alternativ
    this.optionsEl.innerHTML = ''
    
    // Skapa nya knappar
    question.options.forEach((option, index) => {
        const button = document.createElement('button')
        button.className = 'quiz-option'
        button.innerHTML = `<span class="option-label">[${letter}]</span> ${option}`
        
        // Event listeners
        button.addEventListener('click', () => {
            if (!this.hasAnswered) {
                this.submitAnswer(index)
            }
        })
        
        this.optionsEl.appendChild(button)
    })
}
```

**JÃ¤mfÃ¶r med canvas:**
- Ingen `drawWrappedText()` behÃ¶vs
- Ingen manual line breaking
- Browser hanterar allt

### Event Handling

**Mouse + Keyboard:**
```javascript
// Mouse hover (CSS gÃ¶r det visuella)
button.addEventListener('mouseenter', () => {
    if (!this.hasAnswered) {
        this.selectOption(index)
    }
})

// Keyboard (behÃ¥lls fÃ¶r accessibility)
if (keys.has('ArrowDown')) {
    this.selectOption((this.selectedAnswer + 1) % this.currentQuestion.options.length)
}
```

**Dual input support** - bÃ¥de mus och tangentbord fungerar.

## Vite Best Practices

### CSS Import

```javascript
// I QuizDialog.js
import '../styles/ui.css'
```

**Vite hanterar CSS:**
- Hot Module Replacement - CSS uppdateras utan reload
- Bundlar CSS i production
- Tree-shaking av oanvÃ¤nd CSS (med rÃ¤tt config)

### Minimal index.html

```html
<!-- Bara essentials -->
<body>
  <div id="app">
    <canvas id="game"></canvas>
  </div>
  
  <template id="quiz-dialog-template">
    <!-- Template content -->
  </template>
  
  <script type="module" src="/src/main.js"></script>
</body>
```

**Vite filosofi:**
- Minimal HTML
- Import allt i JS
- Build tool hanterar optimering

## Resultat

### Kodreduktion

**FÃ¶re (Canvas version):**
- QuizDialog.js: 260+ rader
- Inkluderar: draw(), drawWrappedText(), manual color management
- SvÃ¥rt att Ã¤ndra design

**Efter (HTML version):**
- QuizDialog.js: ~180 rader (creation logic ersatt med template)
- ui.css: ~180 rader (styling separerat)
- index.html: +15 rader (template)

**Total:** UngefÃ¤r samma mÃ¤ngd kod, men mycket bÃ¤ttre **separation of concerns**.

### FÃ¶rdelar

 **Maintainability** - Styling i CSS, inte JS  
 **Readability** - HTML struktur tydlig  
 **Performance** - Browser optimerar DOM  
 **Accessibility** - Screen readers fungerar  
 **DX** (Developer Experience) - CSS hot reload, native hover, etc.

### Nackdelar

 **Complexity** - Mer filer att hÃ¥lla koll pÃ¥  
 **Layering** - MÃ¥ste fÃ¶rstÃ¥ z-index och positioning  
 **Mixed paradigm** - Canvas + DOM = tvÃ¥ sÃ¤tt att tÃ¤nka

## Integration

### TowerDefenseGame.js

**FÃ¶re:**
```javascript
draw(ctx) {
    // ... game rendering
    
    if (this.gameState === 'QUIZ' && this.currentQuiz) {
        this.currentQuiz.draw(ctx)  // Rita quiz
    }
}
```

**Efter:**
```javascript
draw(ctx) {
    // ... game rendering
    
    // Quiz hanteras nu av DOM, inte canvas
}
```

Quiz-dialogen Ã¤r nu **helt frikopplad** frÃ¥n canvas rendering loop.

### Lifecycle

```javascript
// Skapa quiz
this.currentQuiz = new QuizDialog(this, questions, (totalGold) => {
    // Quiz klar - dialogen dÃ¶ljs automatiskt
    this.gold += totalGold
    this.gameState = 'PLAYING'
})

// QuizDialog skÃ¶ter sjÃ¤lv:
// - Visa overlay
// - Hantera input
// - Uppdatera DOM
// - DÃ¶lja vid complete
```

**SjÃ¤lvstÃ¤ndig komponent** - behÃ¶ver ingen hjÃ¤lp frÃ¥n game loop fÃ¶r rendering.

## Sammanfattning

### LÃ¤rdomar

**RÃ¤tt verktyg fÃ¶r rÃ¤tt jobb:**
- Canvas fÃ¶r dynamisk game rendering
- HTML/CSS fÃ¶r statiska UI elements
- Hybrid approach ger bÃ¤sta av bÃ¥da vÃ¤rldar

**Modern Web Development:**
- `<template>` element fÃ¶r component struktur
- CSS fÃ¶r styling (separation of concerns)
- Vite fÃ¶r build tooling och hot reload
- z-index layering fÃ¶r hybrid rendering

**Trade-offs:**
- NÃ¥got mer komplexitet (tvÃ¥ rendering systems)
- Men mycket bÃ¤ttre maintainability
- Och native browser features (hover, text wrapping, accessibility)

### NÃ¤sta Steg

Detta pattern kan anvÃ¤ndas fÃ¶r:
- Main menu (HTML overlay Ã¶ver canvas)
- Settings dialog
- Tower shop UI
- End screen / score board

NÃ¤r projektet vÃ¤xer kan man Ã¶vervÃ¤ga ett UI framework (React, Vue, Lit) fÃ¶r mer komplex UI, men fÃ¶r ett spel av denna storlek Ã¤r vanilla DOM + templates perfekt.
